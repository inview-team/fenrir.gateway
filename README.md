# ChatOps-бот для управления инцидентами

Этот проект представляет собой бэкенд для интеллектуального ChatOps-бота, предназначенного для управления инцидентами в Kubernetes. Бот получает алерты от Prometheus Alertmanager, сохраняет их в базу данных и предоставляет многоуровневый интерфейс для их расследования и устранения через Telegram.

## Архитектура

- **Telegram Gateway**: Монолитный сервис на Go.
- **База данных**: Локальная SQLite (`chatops.db`) для хранения пользователей и инцидентов.
- **Миграции**: Управляются с помощью `golang-migrate/migrate`.
- **Веб-фреймворк**: `chi` для роутинга HTTP-запросов.
- **Telegram Bot Framework**: `telebot/v3`.
- **ORM**: `GORM` для взаимодействия с базой данных.

## Основные возможности

- **Прием вебхуков от Alertmanager**: Автоматическое создание инцидентов на основе алертов.
- **Персистентное хранилище**: Пользователи и инциденты сохраняются в базе данных SQLite.
- **Гибридный UX**: Реализовано два сценария взаимодействия:
    - **"Быстрый путь" (Two-Click Workflow)**: На главном экране инцидента бот предлагает 2-3 наиболее вероятных действия для решения проблемы, сгенерированных на основе лейблов алерта.
    - **"Глубокое погружение" (Drill-Down)**: Пользователь может "провалиться" от инцидента к списку затронутых ресурсов (например, деплойментов), оттуда — к списку их подов, и для каждого пода выполнить специфичные действия (`посмотреть логи`, `описать`, `удалить`).
- **Жизненный цикл инцидента**: Инциденты имеют статусы (`active`, `resolved`, `rejected`) и полный, неизменяемый лог аудита всех выполненных действий.

## Установка и запуск

### Требования

- Go 1.24+
- `make` (опционально, для удобства)

### 1. Клонирование репозитория

```bash
git clone <URL_РЕПОЗИТОРИЯ>
cd chatops-bot
```

### 2. Установка зависимостей

```bash
go mod tidy
```

### 3. Настройка переменных окружения

Создайте файл `.env` в корне проекта или экспортируйте переменные напрямую.

```bash
# Обязательно
export TELEGRAM_BOT_TOKEN="ВАШ_ТОКЕН_ОТ_BOTFATHER"

# Опционально
export APP_PORT="8080" # Порт для основного API (для Mini App)
export ALERT_PORT="8081" # Порт для вебхуков от Alertmanager
export WEBHOOK_TOKEN="ВАШ_СЕКРЕТНЫЙ_ТОКЕН" # Токен для аутентификации Alertmanager
```

### 4. Запуск приложения

```bash
go run cmd/chatops-bot/main.go
```

При первом запуске будут автоматически применены миграции и создан файл `chatops.db`. Сервер API запустится на порту `APP_PORT`, а сервер для вебхуков — на `ALERT_PORT`.

### 5. Настройка Alertmanager

Чтобы бот получал инциденты, настройте ваш `alertmanager.yml`, добавив в него новый `webhook_configs`. Обратите внимание на порт и заголовок авторизации.

```yaml
receivers:
- name: 'chatops-bot-receiver'
  webhook_configs:
  - url: 'http://localhost:8081/api/v1/alertmanager' # Указываем ALERT_PORT
    http_config:
      bearer_token: "ВАШ_СЕКРЕТНЫЙ_ТОКЕН" # Указываем WEBHOOK_TOKEN
    send_resolved: true

route:
  receiver: 'chatops-bot-receiver'
  group_by: ['alertname', 'cluster', 'service']
  # ... ваши остальные маршруты
```

Перезапустите Alertmanager после внесения изменений.

## Взаимодействие с ботом

- `/start`: Показать приветственное сообщение.
- `/incidents`: Показать список активных инцидентов.
- `/history`: Показать список последних закрытых инцидентов.

При нажатии на инцидент бот покажет его детали и предложит варианты действий. Вы можете либо выбрать одно из предложенных действий ("быстрый путь"), либо перейти к исследованию затронутых ресурсов ("глубокое погружение"), чтобы выполнить более точечные команды.

## Интеграционное тестирование

Для проверки полного цикла получения и обработки алерта без настройки реального Alertmanager можно использовать специальный скрипт.

1.  **Запустите приложение**, как описано выше.
2.  **Выполните скрипт** в новом окне терминала:

    ```bash
    ./send-test-alert.sh
    ```

    Скрипт отправит тестовый алерт на ваш локальный сервер. Вы можете изменить переменные `PORT` и `TOKEN` внутри скрипта или установить переменные окружения `ALERT_PORT` и `WEBHOOK_TOKEN`.

3.  **Проверьте результат** в Telegram: после выполнения скрипта в боте должен появиться новый инцидент.
